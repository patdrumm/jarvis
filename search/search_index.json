{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Table of Contents","text":"<ul> <li>Introduction</li> <li>Documentation</li> <li>Capabilities</li> <li>Installation</li> <li>Example function</li> <li>Citation</li> <li>References</li> <li>How to contribute</li> <li>Correspondence</li> <li>Funding support</li> <li>Code of conduct</li> <li>Module structure</li> </ul>"},{"location":"#jarvis-tools-introduction","title":"JARVIS-Tools (Introduction)","text":"<p>The JARVIS-Tools is an open-access software package for atomistic data-driven materials design. JARVIS-Tools can be used for a) setting up calculations, b) analysis and informatics, c) plotting, d) database development and e) web-page development.</p> <p>JARVIS-Tools empowers NIST-JARVIS (Joint Automated Repository for Various Integrated Simulations) repository which is an integrated framework for computational science using density functional theory, classical force-field/molecular dynamics and machine-learning. The NIST-JARVIS official website is: https://jarvis.nist.gov . This project is a part of the Materials Genome Initiative (MGI) at NIST (https://mgi.nist.gov/).</p> <p>For more details, checkout our latest articles: The joint automated repository for various integrated simulations (JARVIS) for data-driven materials design, Recent progress in the JARVIS infrastructure for next-generation data-driven materials design, other publications and YouTube videos</p> <p> </p> <p> </p> <p></p>"},{"location":"#documentation","title":"Documentation","text":"<p>https://pages.nist.gov/jarvis</p> <p></p>"},{"location":"#capabilities","title":"Capabilities","text":"<ul> <li>Software workflow tasks for preprcessing, executing and     post-processing: VASP, Quantum Espresso, Wien2k BoltzTrap,     Wannier90, LAMMPS, Scikit-learn, TensorFlow, LightGBM, Qiskit,     Tequila, Pennylane, DGL, PyTorch.</li> <li>Several examples: Notebooks and test scripts to explain the     package.</li> <li>Several analysis tools: Atomic structure, Electronic structure,     Spacegroup, Diffraction, 2D materials and other vdW bonded systems,     Mechanical, Optoelectronic, Topological, Solar-cell, Thermoelectric,     Piezoelectric, Dielectric, STM, Phonon, Dark matter, Wannier tight     binding models, Point defects, Heterostructures, Magnetic ordering,     Images, Spectrum etc.</li> <li>Database upload and download: Download JARVIS databases such as     JARVIS-DFT, FF, ML, WannierTB, Solar, STM and also external     databases such as Materials project, OQMD, AFLOW etc.</li> <li>Access raw input/output files: Download input/ouput files for     JARVIS-databases to enhance reproducibility.</li> <li>Train machine learning models: Use different descriptors, graphs     and datasets for training machine learning models.</li> <li>HPC clusters: Torque/PBS and SLURM.</li> <li>Available datasets: Summary of several     datasets     . </li> </ul>"},{"location":"#installation","title":"Installation","text":"<ul> <li> <p>We recommend installing miniconda environment from     https://conda.io/miniconda.html :</p> <pre><code>bash Miniconda3-latest-Linux-x86_64.sh (for linux)\nbash Miniconda3-latest-MacOSX-x86_64.sh (for Mac)\nDownload 32/64 bit python 3.10 miniconda exe and install (for windows)\nNow, let's make a conda environment just for JARVIS::\nconda create --name my_jarvis python=3.10\nsource activate my_jarvis\n</code></pre> </li> <li> <p>Method-1: Installation using pip:</p> <pre><code>pip install -U jarvis-tools\n</code></pre> </li> <li> <p>Method-2: Installation using conda:</p> <pre><code>conda install -c conda-forge jarvis-tools\n</code></pre> </li> <li> <p>Method-3: Installation using setup.py:</p> <pre><code>pip install numpy scipy matplotlib\ngit clone https://github.com/usnistgov/jarvis.git\ncd jarvis\npython setup.py develop\n</code></pre> </li> <li> <p>Method-4: Note on installing additional dependencies (for developers):</p> <pre><code>conda env create --name my_jarvis -f environment.yml\nconda activate my_jarvis\nconda install pytest coverage codecov\ngit clone https://github.com/usnistgov/jarvis.git\ncd jarvis\ngit checkout develop\npython setup.py develop\ncoverage run -m pytest\n</code></pre> </li> </ul> <p></p>"},{"location":"#example-function","title":"Example function","text":"<pre><code>from jarvis.core.atoms import Atoms\nbox = [[2.715, 2.715, 0], [0, 2.715, 2.715], [2.715, 0, 2.715]]\ncoords = [[0, 0, 0], [0.25, 0.25, 0.25]]\nelements = [\"Si\", \"Si\"]\nSi = Atoms(lattice_mat=box, coords=coords, elements=elements)\ndensity = round(Si.density,2)\nprint (density)\n2.33\n\nfrom jarvis.db.figshare import data\ndft_3d = data(dataset='dft_3d')\nprint (len(dft_3d))\n75993\n\n\nfrom jarvis.io.vasp.inputs import Poscar\nfor i in dft_3d:\n    atoms = Atoms.from_dict(i['atoms'])\n    poscar = Poscar(atoms)\n    jid = i['jid']\n    filename = 'POSCAR-'+jid+'.vasp'\n    poscar.write_file(filename)\ndft_2d = data(dataset='dft_2d')\nprint (len(dft_2d))\n1109\n\nfor i in dft_2d:\n    atoms = Atoms.from_dict(i['atoms'])\n    poscar = Poscar(atoms)\n    jid = i['jid']\n    filename = 'POSCAR-'+jid+'.vasp'\n    poscar.write_file(filename)\n# Example to parse DOS data from JARVIS-DFT webpages\nfrom jarvis.db.webpages import Webpage\nfrom jarvis.core.spectrum import Spectrum\nimport numpy as np\nnew_dist=np.arange(-5, 10, 0.05)\nall_atoms = []\nall_dos_up = []\nall_jids = []\nfor ii,i in enumerate(dft_3d):\n  all_jids.append(i['jid'])\n  try:\n    w = Webpage(jid=i['jid'])\n    edos_data = w.get_dft_electron_dos()\n    ens = np.array(edos_data['edos_energies'].strip(\"'\").split(','),dtype='float')\n    tot_dos_up = np.array(edos_data['total_edos_up'].strip(\"'\").split(','),dtype='float')\n    s = Spectrum(x=ens,y=tot_dos_up)\n    interp = s.get_interpolated_values(new_dist=new_dist)\n    atoms=Atoms.from_dict(i['atoms'])\n    ase_atoms=atoms.ase_converter()\n    all_dos_up.append(interp)\n    all_atoms.append(atoms)\n    all_jids.append(i['jid'])\n    filename=i['jid']+'.cif'\n    atoms.write_cif(filename)\n    break\n  except Exception as exp :\n    print (exp,i['jid'])\n    pass\n</code></pre> <p>Find more examples at</p> <ol> <li>https://pages.nist.gov/jarvis/tutorials/</li> <li>https://github.com/JARVIS-Materials-Design/jarvis-tools-notebooks</li> <li>https://github.com/usnistgov/jarvis/tree/master/jarvis/tests/testfiles</li> </ol> <p></p>"},{"location":"#citing","title":"Citing","text":"<p>Please cite the following if you happen to use JARVIS-Tools for a publication.</p> <p>https://www.nature.com/articles/s41524-020-00440-1</p> <p>Choudhary, K. et al. The joint automated repository for various integrated simulations (JARVIS) for data-driven materials design. npj Computational Materials, 6(1), 1-13 (2020).</p> <p></p>"},{"location":"#references","title":"References","text":"<p>Please see Publications related to JARVIS-Tools</p> <p></p>"},{"location":"#how-to-contribute","title":"How to contribute","text":"<p>For detailed instructions, please see Contribution instructions</p> <p></p>"},{"location":"#correspondence","title":"Correspondence","text":"<p>Please report bugs as Github issues (https://github.com/usnistgov/jarvis/issues) or email to kamal.choudhary@nist.gov.</p> <p></p>"},{"location":"#funding-support","title":"Funding support","text":"<p>NIST-MGI (https://www.nist.gov/mgi).</p> <p></p>"},{"location":"#code-of-conduct","title":"Code of conduct","text":"<p>Please see Code of conduct</p> <p></p>"},{"location":"#module-structure","title":"Module structure","text":"<pre><code>jarvis/\n\u251c\u2500\u2500 ai\n\u2502   \u251c\u2500\u2500 descriptors\n\u2502   \u2502   \u251c\u2500\u2500 cfid.py\n\u2502   \u2502   \u251c\u2500\u2500 coulomb.py\n\u2502   \u251c\u2500\u2500 gcn\n\u2502   \u251c\u2500\u2500 pkgs\n\u2502   \u2502   \u251c\u2500\u2500 lgbm\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 classification.py\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 regression.py\n\u2502   \u2502   \u251c\u2500\u2500 sklearn\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 classification.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 hyper_params.py\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 regression.py\n\u2502   \u2502   \u2514\u2500\u2500 utils.py\n\u2502   \u251c\u2500\u2500 uncertainty\n\u2502   \u2502   \u2514\u2500\u2500 lgbm_quantile_uncertainty.py\n\u251c\u2500\u2500 analysis\n\u2502   \u251c\u2500\u2500 darkmatter\n\u2502   \u2502   \u2514\u2500\u2500 metrics.py\n\u2502   \u251c\u2500\u2500 defects\n\u2502   \u2502   \u251c\u2500\u2500 surface.py\n\u2502   \u2502   \u2514\u2500\u2500 vacancy.py\n\u2502   \u251c\u2500\u2500 diffraction\n\u2502   \u2502   \u2514\u2500\u2500 xrd.py\n\u2502   \u251c\u2500\u2500 elastic\n\u2502   \u2502   \u2514\u2500\u2500 tensor.py\n\u2502   \u251c\u2500\u2500 interface\n\u2502   \u2502   \u2514\u2500\u2500 zur.py\n\u2502   \u251c\u2500\u2500 magnetism\n\u2502   \u2502   \u2514\u2500\u2500 magmom_setup.py\n\u2502   \u251c\u2500\u2500 periodic\n\u2502   \u2502   \u2514\u2500\u2500 ptable.py\n\u2502   \u251c\u2500\u2500 phonon\n\u2502   \u2502   \u251c\u2500\u2500 force_constants.py\n\u2502   \u2502   \u2514\u2500\u2500 ir.py\n\u2502   \u251c\u2500\u2500 solarefficiency\n\u2502   \u2502   \u2514\u2500\u2500 solar.py\n\u2502   \u251c\u2500\u2500 stm\n\u2502   \u2502   \u2514\u2500\u2500 tersoff_hamann.py\n\u2502   \u251c\u2500\u2500 structure\n\u2502   \u2502   \u251c\u2500\u2500 neighbors.py\n\u2502   \u2502   \u251c\u2500\u2500 spacegroup.py\n\u2502   \u251c\u2500\u2500 thermodynamics\n\u2502   \u2502   \u251c\u2500\u2500 energetics.py\n\u2502   \u251c\u2500\u2500 topological\n\u2502   \u2502   \u2514\u2500\u2500 spillage.py\n\u251c\u2500\u2500 core\n\u2502   \u251c\u2500\u2500 atoms.py\n\u2502   \u251c\u2500\u2500 composition.py\n\u2502   \u251c\u2500\u2500 graphs.py\n\u2502   \u251c\u2500\u2500 image.py\n\u2502   \u251c\u2500\u2500 kpoints.py\n\u2502   \u251c\u2500\u2500 lattice.py\n\u2502   \u251c\u2500\u2500 pdb_atoms.py\n\u2502   \u251c\u2500\u2500 specie.py\n\u2502   \u251c\u2500\u2500 spectrum.py\n\u2502   \u2514\u2500\u2500 utils.py\n\u251c\u2500\u2500 db\n\u2502   \u251c\u2500\u2500 figshare.py\n\u2502   \u251c\u2500\u2500 jsonutils.py\n\u2502   \u251c\u2500\u2500 lammps_to_xml.py\n\u2502   \u251c\u2500\u2500 restapi.py\n\u2502   \u251c\u2500\u2500 vasp_to_xml.py\n\u2502   \u2514\u2500\u2500 webpages.py\n\u251c\u2500\u2500 examples\n\u2502   \u251c\u2500\u2500 lammps\n\u2502   \u2502   \u251c\u2500\u2500 jff_test.py\n\u2502   \u2502   \u251c\u2500\u2500 Al03.eam.alloy_nist.tgz\n\u2502   \u251c\u2500\u2500 vasp\n\u2502   \u2502   \u251c\u2500\u2500 dft_test.py\n\u2502   \u2502   \u251c\u2500\u2500 SiOptb88.tgz\n\u251c\u2500\u2500 io\n\u2502   \u251c\u2500\u2500 boltztrap\n\u2502   \u2502   \u251c\u2500\u2500 inputs.py\n\u2502   \u2502   \u2514\u2500\u2500 outputs.py\n\u2502   \u251c\u2500\u2500 calphad\n\u2502   \u2502   \u2514\u2500\u2500 write_decorated_poscar.py\n\u2502   \u251c\u2500\u2500 lammps\n\u2502   \u2502   \u251c\u2500\u2500 inputs.py\n\u2502   \u2502   \u2514\u2500\u2500 outputs.py\n\u2502   \u251c\u2500\u2500 pennylane\n\u2502   \u2502   \u251c\u2500\u2500 inputs.py\n\u2502   \u251c\u2500\u2500 phonopy\n\u2502   \u2502   \u251c\u2500\u2500 fcmat2hr.py\n\u2502   \u2502   \u251c\u2500\u2500 inputs.py\n\u2502   \u2502   \u2514\u2500\u2500 outputs.py\n\u2502   \u251c\u2500\u2500 qe\n\u2502   \u2502   \u251c\u2500\u2500 inputs.py\n\u2502   \u2502   \u2514\u2500\u2500 outputs.py\n\u2502   \u251c\u2500\u2500 qiskit\n\u2502   \u2502   \u251c\u2500\u2500 inputs.py\n\u2502   \u251c\u2500\u2500 tequile\n\u2502   \u2502   \u251c\u2500\u2500 inputs.py\n\u2502   \u251c\u2500\u2500 vasp\n\u2502   \u2502   \u251c\u2500\u2500 inputs.py\n\u2502   \u2502   \u2514\u2500\u2500 outputs.py\n\u2502   \u251c\u2500\u2500 wannier\n\u2502   \u2502   \u251c\u2500\u2500 inputs.py\n\u2502   \u2502   \u2514\u2500\u2500 outputs.py\n\u2502   \u251c\u2500\u2500 wanniertools\n\u2502   \u2502   \u251c\u2500\u2500 inputs.py\n\u2502   \u2502   \u2514\u2500\u2500 outputs.py\n\u2502   \u251c\u2500\u2500 wien2k\n\u2502   \u2502   \u251c\u2500\u2500 inputs.py\n\u2502   \u2502   \u251c\u2500\u2500 outputs.py\n\u251c\u2500\u2500 tasks\n\u2502   \u251c\u2500\u2500 boltztrap\n\u2502   \u2502   \u2514\u2500\u2500 run.py\n\u2502   \u251c\u2500\u2500 lammps\n\u2502   \u2502   \u251c\u2500\u2500 templates\n\u2502   \u2502   \u2514\u2500\u2500 lammps.py\n\u2502   \u251c\u2500\u2500 phonopy\n\u2502   \u2502   \u2514\u2500\u2500 run.py\n\u2502   \u251c\u2500\u2500 vasp\n\u2502   \u2502   \u2514\u2500\u2500 vasp.py\n\u2502   \u251c\u2500\u2500 queue_jobs.py\n\u251c\u2500\u2500 tests\n\u2502   \u251c\u2500\u2500 testfiles\n\u2502   \u2502   \u251c\u2500\u2500 ai\n\u2502   \u2502   \u251c\u2500\u2500 analysis\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 darkmatter\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 defects\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 elastic\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 interface\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 magnetism\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 periodic\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 phonon\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 solar\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 stm\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 structure\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 thermodynamics\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 topological\n\u2502   \u2502   \u251c\u2500\u2500 core\n\u2502   \u2502   \u251c\u2500\u2500 db\n\u2502   \u2502   \u251c\u2500\u2500 io\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 boltztrap\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 calphad\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 lammps\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 pennylane\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 phonopy\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 qiskit\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 qe\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 tequila\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 vasp\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 wannier\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 wanniertools\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 wien2k\n\u2502   \u2502   \u251c\u2500\u2500 tasks\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 test_lammps.py\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 test_vasp.py\n\u2514\u2500\u2500 README.rst\n</code></pre>"},{"location":"databases/","title":"Databases","text":""},{"location":"databases/#figshare-based-databases","title":"FigShare based databases","text":"Database name Number of data-points Description <code>AGRA_CHO</code> 214 AGRA CHO catalyst dataset <code>AGRA_COOH</code> 280 AGRA COOH catalyst dataset <code>AGRA_CO</code> 193 AGRA CO catalyst dataset <code>AGRA_OH</code> 875 AGRA OH catalyst dataset <code>AGRA_O</code> 1000 AGRA Oxygen catalyst dataset <code>aflow2</code> 400k AFLOW dataset <code>alex_pbe_1d_all</code> 100k Alexandria DB all 1D materials with PBE <code>alex_pbe_2d_all</code> 200k Alexandria DB all 2D materials with PBE <code>alex_pbe_3d_all</code> 5 million Alexandria DB all 3D materials with PBE <code>alex_pbe_hull</code> 116k Alexandria DB convex hull stable materials with PBE functional <code>alex_pbesol_3d_all</code> 500k Alexandria DB all 3D materials with PBEsol <code>alex_scan_3d_all</code> 500k Alexandria DB all 3D materials with SCAN <code>alignn_ff_db</code> 307113 Energy per atom, forces and stresses for ALIGNN-FF trainig for 75k materials. <code>arXiv</code> 1796911 arXiv dataset 1.8 million title, abstract and id dataset <code>arxiv_summary</code> 137927 arXiv summary dataset <code>c2db</code> 3514 Various properties in C2DB database <code>cccbdb</code> 1333 CCCBDB dataset <code>cfid_3d</code> 55723 Various 3D materials properties in JARVIS-DFT database computed with OptB88vdW and TBmBJ methods with CFID <code>cod</code> 431778 Atomic structures from crystallographic open database <code>dft_2d_2021</code> 1079 Various 2D materials properties in JARVIS-DFT database computed with OptB88vdW <code>dft_2d</code> 1109 Various 2D materials properties in JARVIS-DFT database computed with OptB88vdW <code>dft_3d_2021</code> 55723 Various 3D materials properties in JARVIS-DFT database computed with OptB88vdW and TBmBJ methods <code>dft_3d</code> 75993 Various 3D materials properties in JARVIS-DFT database computed with OptB88vdW and TBmBJ methods <code>edos_pdos</code> 48469 Normalized electron and phonon density of states with interpolated values and fixed number of bins <code>halide_peroskites</code> 229 Halide perovskite dataset <code>hmof</code> 137651 Hypothetical MOF database <code>hopv</code> 4855 Various properties of molecules in HOPV15 dataset <code>interfacedb</code> 593 Interface property dataset <code>jff</code> 2538 Various 3D materials properties in JARVIS-FF database computed with several force-fields <code>m3gnet_mpf_1.5mil</code> 1.5 million 1.5 million structures  and their energy, forces and stresses in MP <code>m3gnet_mpf</code> 168k 168k structures and their energy, forces and stresses in MP <code>megnet2</code> 133k 133k materials and their formation energy in MP <code>megnet</code> 69239 Formation energy and bandgaps of 3D materials properties in Materials project database as on 2018, used in megnet <code>mlearn</code> 1730 Machine learning force-field for elements datasets <code>mp_3d_2020</code> 127k CFID descriptors for materials project <code>mp_3d</code> 84k CFID descriptors for 84k materials project <code>mxene275</code> 275 MXene dataset <code>ocp100k</code> 149886 Open Catalyst 100000 training, rest validation and test dataset <code>ocp10k</code> 59886 Open Catalyst 10000 training, rest validation and test dataset <code>ocp_all</code> 510214 Open Catalyst 460328 training, rest validation and test dataset <code>omdb</code> 12500 Bandgaps for organic polymers in OMDB database <code>oqmd_3d_no_cfid</code> 817636 Formation energies and bandgaps of 3D materials from OQMD database <code>oqmd_3d</code> 460k CFID descriptors for 460k materials in OQMD <code>pdbbind_core</code> 195 Bio-molecular complexes database from PDBBind core <code>pdbbind</code> 11189 Bio-molecular complexes database from PDBBind v2015 <code>polymer_genome</code> 1073 Electronic bandgap and diecltric constants of crystall ine polymer in polymer genome database <code>qe_tb</code> 829574 Various 3D materials properties in JARVIS-QETB database <code>qm9_dgl</code> 130829 Various properties of molecules in QM9 dgl database <code>qm9_std_jctc</code> 130829 Various properties of molecules in QM9 database <code>qmof</code> 20425 Bandgaps and total energies of metal organic frameowrks in QMOF database <code>raw_files</code> 144895 Figshare links to download raw calculations VASP files from JARVIS-DFT <code>snumat</code> 10481 Bandgaps with hybrid functional <code>ssub</code> 1726 SSUB formation energy for chemical formula dataset <code>stm</code> 1132 2D materials STM images in JARVIS-STM database <code>supercon_2d</code> 161 2D superconductor DFT dataset <code>supercon_3d</code> 1058 3D superconductor DFT dataset <code>supercon_chem</code> 16414 Superconductor chemical formula dataset <code>surfacedb</code> 607 Surface property dataset <code>tinnet_N</code> 329 TinNet Nitrogen catalyst dataset <code>tinnet_OH</code> 748 TinNet OH group catalyst dataset <code>tinnet_O</code> 747 TinNet Oxygen catalyst dataset <code>twod_matpd</code> 6351 Formation energy and bandgaps of 2D materials properties in 2DMatPedia database <code>vacancydb</code> 464 Vacancy formation energy dataset <code>wtbh_electron</code> 1440 3D and 2D materials Wannier tight-binding Hamiltonian dtaabase for electrons with spin-orbit coupling in JARVIS-WTB (Keyword: 'WANN') <code>wtbh_phonon</code> 15502 3D and 2D materials Wannier tight-binding Hamiltonian for phonons at Gamma with finite difference (Keyword:FD-ELAST) <p>All these datasets can be obtained using jarvis-tools as follows, exception to <code>stm</code>, <code>wtbh_electron</code>, <code>wtbh_phonon</code> which have their own modules in <code>jarvis.db.figshare</code>:</p> <pre><code>from jarvis.db.figshare import data\nd = data('dft_3d') #choose a name of dataset from above\n# See available keys\nprint (d[0].keys())\n# Dataset size\nprint(len(d))\n\n# Visualize an atoms object\nfrom jarvis.core.atoms import Atoms\na = Atoms.from_dict(d[0]['atoms'])\n#You can visualize this in VESTA or other similar packages\nprint(a)\n\n# If pandas framework needed\nimport pandas as pd\ndf = pd.DataFrame(d)\nprint(df)\n</code></pre>"},{"location":"publications/","title":"Publications","text":""},{"location":"publications/#jarvis-overview","title":"JARVIS-Overview","text":"<p>[1. The joint automated repository for various integrated simulations (JARVIS) for data-driven materials design, npj Computational Materials 6, 173 (2020).](https://www.nature.com/articles/s41524-020-00440-1)</p> <p>[2. Recent progress in the JARVIS infrastructure for next-generation data-driven materials design, arXiv (2023).](https://arxiv.org/abs/2305.11842)</p> <p>[3. Large Scale Benchmark of Materials Design Methods, arXiv(2023).](https://arxiv.org/abs/2306.11688)</p>"},{"location":"publications/#jarvis-ff","title":"JARVIS-FF","text":"<p>[4. Evaluation and comparison of classical interatomic potentials through a user-friendly interactive web-interface, Nature: Sci Data. 4, 160125 (2017).](https://www.nature.com/articles/sdata2016125)</p> <p>[5. High-throughput assessment of vacancy formation and surface energies of materials using classical force-fields, J. Phys. Cond. Matt. 30, 395901(2018).](http://iopscience.iop.org/article/10.1088/1361-648X/aadaff/meta)</p>"},{"location":"publications/#jarvis-dft-related","title":"JARVIS-DFT related","text":"<p>[6. High-throughput Identification and Characterization of Two-dimensional Materials using Density functional theory, Scientific Reports 7, 5179 (2017).](https://www.nature.com/articles/s41598-017-05402-0)</p> <p>[7. Computational Screening of High-performance Optoelectronic Materials using OptB88vdW and TBmBJ Formalisms, Scientific Data 5, 180082 (2018).](https://www.nature.com/articles/sdata201882)</p> <p>[8. Elastic properties of bulk and low-dimensional materials using van der Waals density functional, Phys. Rev. B, 98, 014107 (2018).](https://journals.aps.org/prb/abstract/10.1103/PhysRevB.98.014107)</p> <p>[9. High-throughput Discovery of Topologically Non-trivial Materials using Spin-orbit Spillage, Nature: Sci. Rep. 9, 8534,(2019).](https://www.nature.com/articles/s41598-019-45028-y)</p> <p>[10. Computational Search for Magnetic and Non-magnetic 2D Topological Materials using Unified Spin-orbit Spillage Screening, npj Comp. Mat., 6, 49 (2020).](https://www.nature.com/articles/s41524-020-0319-4)</p> <p>[11. Density Functional Theory based Electric Field Gradient Database, Sci. Data 7, 362 (2020).](https://www.nature.com/articles/s41597-020-00707-8)</p> <p>[12. Computational scanning tunneling microscope image database, Sci. Data, 8, 57 (2021).](https://www.nature.com/articles/s41597-021-00824-y)</p> <p>[13. Database of Wannier Tight-binding Hamiltonians using High-throughput Density Functional Theory, Sci. Data](https://www.nature.com/articles/s41597-021-00885-z)</p> <p>[14. Predicting Anomalous Quantum Confinement Effect in van der Waals Materials, Phys. Rev. Mat.](https://journals.aps.org/prmaterials/abstract/10.1103/PhysRevMaterials.5.054602)</p> <p>[15. High-throughput search for magnetic topological materials using spin-orbit spillage, machine-learning and experiments, Phys. Rev. B](https://journals.aps.org/prb/abstract/10.1103/PhysRevB.103.155131)</p> <p>[16. Density functional theory-based electric field gradient database, Sci. Data](https://www.nature.com/articles/s41597-020-00707-8)</p> <p>[17. High-throughput DFT-based discovery of next generation two-dimensional (2D) superconductors](https://pubs.acs.org/doi/full/10.1021/acs.nanolett.2c04420)</p> <p>[18. A systematic DFT+U and Quantum Monte Carlo benchmark of magnetic two-dimensional (2D) CrX (X = I, Br, Cl, F)](https://pubs.acs.org/doi/abs/10.1021/acs.jpcc.2c06733)</p>"},{"location":"publications/#jarvis-ml-related","title":"JARVIS-ML related","text":"<p>[19. Machine learning with force-field inspired descriptors for materials: fast screening and mapping energy landscape, Phys. Rev. Mat., 2, 083801 (2018).](https://journals.aps.org/prmaterials/abstract/10.1103/PhysRevMaterials.2.083801)</p> <p>[28. Convergence and machine learning predictions of Monkhorst-Pack k-points and plane-wave cut-off in high-throughput DFT calculations, Comp. Mat. Sci. 161, 300 (2019).](https://www.sciencedirect.com/science/article/pii/S0927025619300813?via%3Dihub)</p> <p>[21. Materials science in the artificial intelligence age: high-throughput library generation, machine learning, and a pathway from correlations to the underpinning physics, MRS Comm., 1-18, 2019.](https://doi.org/10.1557/mrc.2019.95)</p> <p>[22. Enhancing materials property prediction by leveraging computational and experimental data using deep transfer learning, Nature Comm., 10, 1, (2019).](https://www.nature.com/articles/s41467-019-13297-w)</p> <p>[23. Accelerated Discovery of Efficient Solar-cell Materials using Quantum and Machine-learning Methods, Chem. Mater., 31, 5900 (2019).](https://pubs.acs.org/doi/10.1021/acs.chemmater.9b02166)</p> <p>[24. High-throughput Density Functional Perturbation Theory and Machine Learning Predictions of Infrared, Piezoelectric and Dielectric Responses, npj Computational Materials 6, 64 (2020).](https://www.nature.com/articles/s41524-020-0337-2)</p> <p>[25. Data-driven Discovery of 3D and 2D Thermoelectric Materials, J. Phys.: Cond. Matt.](https://iopscience.iop.org/article/10.1088/1361-648X/aba06b/meta)</p> <p>[26. Efficient Computational Design of 2D van der Waals Heterostructures: Band-Alignment, Lattice-Mismatch, Web-app Generation and Machine-learning.](https://arxiv.org/abs/2004.03025)</p> <p>[27. Enhancing materials property prediction by leveraging computational and experimental data using deep transfer learning, Nature Commun.](https://www.nature.com/articles/s41467-019-13297-w)</p> <p>[28. Atomistic Line Graph Neural Network for Improved Materials Property Predictions, npj Computational Materials 7, 1 (2021)](https://www.nature.com/articles/s41524-021-00650-1)</p> <p>[29. Recent advances and applications of deep learning methods in materials science, npj Computational Materials 8, 1 (2022)](https://www.nature.com/articles/s41524-022-00734-6)</p> <p>[30. Graph neural network predictions of metal organic framework CO2 adsorption properties, Comp. Mat. Sci., 210, 111388 (2022)](https://www.sciencedirect.com/science/article/pii/S092702562200163X)</p> <p>[31. Data-Driven Multi-Scale Modeling and Optimization for Elastic Properties of Cubic Microstructures](https://link.springer.com/article/10.1007/s40192-022-00258-3)</p> <p>[32. Uncertainty Prediction for Machine Learning Models of Material Properties](https://pubs.acs.org/doi/abs/10.1021/acsomega.1c03752)</p> <p>[33. Cross-property deep transfer learning framework for enhanced predictive analytics on small materials data](https://www.nature.com/articles/s41467-021-26921-5)</p> <p>[34. Prediction of the Electron Density of States for Crystalline Compounds with Atomistic Line Graph Neural Networks (ALIGNN)](https://link.springer.com/article/10.1007/s11837-022-05199-y)</p> <p>[35. Designing High-Tc Superconductors with BCS-inspired Screening, Density Functional Theory and Deep-learning](https://arxiv.org/abs/2205.00060)</p> <p>[36. Rapid Prediction of Phonon Structure and Properties using an Atomistic Line Graph Neural Network (ALIGNN)](https://journals.aps.org/prmaterials/abstract/10.1103/PhysRevMaterials.7.023803)</p> <p>[37. Unified Graph Neural Network Force-field for the Periodic Table](https://pubs.rsc.org/en/content/articlehtml/2023/dd/d2dd00096b)</p> <p>[38. AtomVision: A machine vision library for atomistic images](https://pubs.acs.org/doi/full/10.1021/acs.jcim.2c01533)</p> <p>[39. ChemNLP: A Natural Language Processing based Library for Materials Chemistry Text Data](https://arxiv.org/abs/2209.08203)</p> <p>[40. A critical examination of robustness and generalizability of machine learning prediction of materials properties](https://www.nature.com/articles/s41524-023-01012-9)</p> <p>[41. Inverse design of next-generation superconductors using data-driven deep generative models](https://pubs.acs.org/doi/10.1021/acs.jpclett.3c01260)</p>"},{"location":"publications/#jarvis-qc-related","title":"JARVIS-QC related","text":"<p>[42. Quantum Computation for Predicting Electron and Phonon Properties of Solids., J. Phys.: Cond. Matt.](https://iopscience.iop.org/article/10.1088/1361-648X/ac1154)</p>"},{"location":"publications/#jarvis-qetb-related","title":"JARVIS-QETB related","text":"<p>[43. Fast and Accurate Prediction of Material Properties with Three-Body Tight-Binding Model for the Periodic Table](https://journals.aps.org/prmaterials/abstract/10.1103/PhysRevMaterials.7.044603)</p>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#quickstart-with-jupytergoogle-colab-notebooks-httpsgithubcomusnistgovaims2024_workshop","title":"Quickstart with Jupyter/Google-colab notebooks: https://github.com/usnistgov/aims2024_workshop","text":"<p>More detailed tutorials below:</p>"},{"location":"tutorials/#how-to-analyze-an-atomic-structure","title":"How to analyze an atomic structure","text":"<p>Atomic structure act as an input to multiple simulations such as for density functional theory, molecular dyanmics, Monte Carlo, atomistic graph neural network etc. So, we provide a very bried introduction to the atomic structure here. For more general information, refer to solid-state physics or introduction to materials-science books.</p> <p>An atomic structure can consist of atomic element types, corresponding xyz coordinates in space (either in real or reciprocal space) and lattice matrix used in setting periodic boundary conditions.</p> <p>An example of constructing an atomic structure class using <code>jarvis.core.Atoms</code> is given below. After creating the Atoms class, we can simply print it and visualize the POSCAR format file in a software such as VESTA. While the examples below use Silicon elemental crystal creation and analysis, it can be used for multi-component systems as well.</p> <pre><code>from jarvis.core.atoms import Atoms\nbox = [[2.715, 2.715, 0], [0, 2.715, 2.715], [2.715, 0, 2.715]]\ncoords = [[0, 0, 0], [0.25, 0.25, 0.25]]\nelements = [\"Si\", \"Si\"]\nSi = Atoms(lattice_mat=box, coords=coords, elements=elements, cartesian=False)\nprint (Si) # To visualize \nSi.write_poscar('POSCAR.vasp')\nSi.write_cif('POSCAR.vasp')\n</code></pre> <p>The Atoms class here is created from the raw data, but it can also be read from different file formats such as: '.cif', 'POSCAR', '.xyz', '.pdb', '.sdf', '.mol2' etc. The Atoms class can also be written to files in formats such as POSCAR/.cif etc.</p> <p>Note that for molecular systems, we use a large vaccum padding (say 50 Angstrom in each direction) and set lattice_mat accordingly, e.g. lattice_mat = [[50,0,0],[0,50,0],[0,0,50]]. Similarly, for free surfaces we set high vaccum in one of the crystallographic directions (say z) by giving a large z-comonent in the lattice matrix while keeping the x, y comonents intact.</p> <pre><code>my_atoms = Atoms.from_poscar('POSCAR')\nmy_atoms.write_poscar('MyPOSCAR')\n</code></pre> <p>Once this Atoms class is created, several imprtant information can be obtained such as:</p> <pre><code>print ('volume',Si.volume)\nprint ('density in g/cm3', Si.density)\nprint ('composition as dictionary', Si.composition)\nprint ('Chemical formula', Si.composition.reduced_formula)\nprint ('Spacegroup info', Si.spacegroup())\nprint ('lattice-parameters', Si.lattice.abc, Si.lattice.angles)\nprint ('packing fraction',Si.packing_fraction)\nprint ('number of atoms',Si.num_atoms)\nprint ('Center of mass', Si.get_center_of_mass())\nprint ('Atomic number list', Si.atomic_numbers)\n</code></pre> <p>For creating/accessing dataset(s), we use <code>Atoms.from_dict()</code> and <code>Atoms.to_dict()</code> methods:</p> <pre><code>d = Si.to_dict()\nnew_atoms = Atoms.from_dict(d)\n</code></pre> <p>The jarvis.core.Atoms object can be converted back and forth to other simulation toolsets such as Pymatgen and ASE if insyalled, as follows</p> <pre><code>pmg_struct = Si.pymatgen_converter()\nase_atoms = Si.ase_converter()\n</code></pre> <p>In order to make supercell, the following example can be used:</p> <pre><code>supercell_1 = Si.make_supercell([2,2,2])\nsupercell_2 = Si.make_supercell_matrix([[2,0,0],[0,2,0],[0,0,2]])\nsupercell_1.density == supercell_2.density\n</code></pre>"},{"location":"tutorials/#how-to-get-rdf-adf-ddf","title":"How to get RDF, ADF, DDF","text":"<p>Nearest-neighbor analysis one of the most important tools in atomistic simulations. Quantities such as radial (RDF), angle (ADF) and dihedral (DDF) distribution functions can be obtained using jarvis.analysis.structure.neighbors.NeighborsAnalysis class as shown in the following example using the Si Atoms class obtained above. Different cut-off parameters for angle and sihedral distribution are used to narrow down the number of neighbors. For details, please look into respective modules.</p> <pre><code>nb = NeighborsAnalysis(Si)\nbins_rdf, rdf, nbs = nb.get_rdf() #Global Radial distribution function\nadfa, bins_a = nb.ang_dist_first() #Angular distribution function upto first neighbor\nadfb, bins_b = nb.ang_dist_second() #Angular distribution function upto second neighbor\nddf, bins_d = nb.get_ddf() #Dihedral distribution function upto first neighbor\nimport matplotlib\n%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom matplotlib.gridspec import GridSpec\n\nthe_grid = GridSpec(2, 2)\nplt.rcParams.update({'font.size': 24})\nplt.figure(figsize=(16,14))\n\nplt.subplot(the_grid[0, 0])\nplt.title('(a) RDF')\nplt.plot(bins_rdf, rdf)\nplt.xlabel(r'Distance bins ($\\AA$)')\n\nplt.subplot(the_grid[0, 1])\nplt.title('(b) ADF-a')\nplt.plot(bins_a[:-1], adfa)\nplt.xlabel(r'Angle bins ($^\\circ$)')\n\nplt.subplot(the_grid[1, 0])\nplt.title('(c) ADF-b')\nplt.plot(bins_b[:-1], adfb)\nplt.xlabel(r'Angle bins ($^\\circ$)')\n\nplt.subplot(the_grid[1, 1])\nplt.title('(d) DDF')\nplt.plot(bins_d[:-1], ddf)\nplt.xlabel(r'Angle bins ($^\\circ$)')\nplt.tight_layout()\n</code></pre>"},{"location":"tutorials/#how-to-get-xrd-paterns","title":"How to get XRD paterns","text":"<p>X-ray diffraction patterns act as one of the most important experimental methods for determining atomic structure. Using Cu-K alpha wavelength, the theoretical XRD patterns (two-theta and d_hkl dependence) for Si class above can be obatined as follows.</p> <pre><code>import matplotlib.pyplot as plt\nfrom matplotlib.gridspec import GridSpec\n\nSi = Atoms(lattice_mat=box, coords=coords, elements=elements)\na, b, c = XRD().simulate(atoms=atoms)\n\nthe_grid = GridSpec(1,2)\nplt.rcParams.update({'font.size': 24})\nplt.figure(figsize=(10,5))\n\nplt.subplot(the_grid[0])\nplt.bar(a,c)\nplt.xlabel('2$\\Theta$')\nplt.ylabel('XRD intensity')\nplt.subplot(the_grid[1])\nplt.bar(a,b)\nplt.xlabel('d$_{hkl}$')\nplt.ylabel('XRD intensity')\nplt.tight_layout()\n</code></pre>"},{"location":"tutorials/#how-to-make-defects","title":"How to make defects","text":"<p>While the above Si atomic structure generated above is perfect/defect free, in reality there can be several defects present in an atomic structure such as point defects (vacancies, interstitials, substituions), line defects (dislocations), surface-defects (free-surfaces, grain boundaries, stacking faults, interfaces), volume-defects (voids/pores) etc.</p> <p>An example of creating vacancy structures using unique Wycoff positions is shown below:</p> <pre><code>from jarvis.analysis.defects.vacancy import Vacancy\n#enforces cell-size to be close to 10 Angstroms\nvacs = Vacancy(atoms=Si).generate_defects(enforce_c_size=10.0)\nlen(vacs), vacs[0].to_dict()[\"defect_structure\"].num_atoms\n# We find that there are only one unique point vacanc available based on Wycoff-position information\n</code></pre> <p>Similarly, an example of creating, free surfaces is shown below:</p> <pre><code>from jarvis.analysis.defects.surface import wulff_normals, Surface\n\n# Let's create (1,1,1) surface with three layers, and vacuum=18.0 Angstrom\n# We center it around origin so that it looks good during visualization\nsurface_111 = (\n    Surface(atoms=Si, indices=[1, 1, 1], layers=3, vacuum=18)\n        .make_surface()\n        .center_around_origin()\n)\nprint(surface_111)\n</code></pre> <p>While the above example makes only one surface (111), we can ask jarvis-tools to provide all symmetrically distinct surfaces as follows:</p> <pre><code>from jarvis.analysis.structure.spacegroup import (\n    Spacegroup3D,\n    symmetrically_distinct_miller_indices,\n)\nspg = Spacegroup3D(atoms=Si)\ncvn = spg.conventional_standard_structure\nmills = symmetrically_distinct_miller_indices(max_index=3, cvn_atoms=cvn)\nfor i in mills:\n    surf = Surface(atoms=Si, indices=i, layers=3, vacuum=18).make_surface()\n    print ('Index:', i)\n    print (surf)\n</code></pre> <p>Heterostructures of a film and a substrate can be created using ZSL algorithm as shown in the following example:</p> <pre><code>from jarvis.analysis.interface.zur import ZSLGenerator, mismatch_strts, get_hetero, make_interface\nfilm = Surface(atoms=Si, indices=[1, 1, 1], layers = 3, vacuum = 18 ).make_surface().center_around_origin() \nsubstrate = Surface(atoms=Si, indices=[1, 1, 1], layers = 3, vacuum = 18 ).make_surface().center_around_origin()  \ninfo = make_interface(film=film, subs=substrate)['interface'].center(vacuum=18)\nprint (info)\n</code></pre>"},{"location":"tutorials/#how-to-setupanalyze-dft-calculations-using-vasp","title":"How to setup/analyze DFT calculations using VASP","text":"<p>The Vienna Ab initio Simulation Package (VASP) is a package for performing ab initio quantum mechanical calculations using either Vanderbilt pseudopotentials, or the projector augmented wave method, and a plane wave basis set. Manual for VASP is available at: https://www.vasp.at/wiki/index.php/The_VASP_Manual .</p> <p>Running a VASP calculation requires the following files: <code>INCAR</code>, <code>POSCAR</code>, <code>KPOINTS</code>, <code>POTCAR</code> as well as additional files such as <code>vdw_kernel.bindat</code> for specific types of calculations. While setting up calculations for one or a few systems/setups should be straight forward, setting up calculations for thousands of materials and most importantly making a database out of all those calculations require automated calculations script collections such as JARVIS-Tools.</p> <p>Gievn an atomic structure in 1) <code>jarvis.core.Atoms</code> format, JARVIS-Tools 2) prepares input files such as <code>INCAR</code> etc. as mentioned above and 3) submits the calculations to your queuing system such as SLURM/PBS using <code>jarvis.tasks.vasp</code> and <code>jarvis.tasks.queue_jobs</code>. After a calculations get completed, 4) automated analysis can be carried out and plots and webpages are generated. The input file generation and output file parsing modules for VASP can be found in <code>jarvis.io.vasp.inputs</code> and <code>jarvis.io.vasp.outputs</code> modules. The automated analyis and XML generation for webpages can be found in <code>jarvis.db.vasp_to_xml</code> module. After the xml page creation they are converted using html using XSLT scripts.</p> <p>Additionally, a JSON file is created with metadata from all the XML pages for thousands of materials to easily use in data-analytics/machine learning applications.The JARVIS-DFT (https://jarvis.nist.gov/jarvisdft/) database primarily uses such a workflow. Make sure <code>VASP_PSP_DIR</code> is declared as a PATH to VASP pseudopotential directory i.e.</p> <pre><code>$ export VASP_PSP_DIR=YOUR_PATH_TO_PSUEDOPTENTIALS\n</code></pre> <p>in your ~/.bashrc file.</p>"},{"location":"tutorials/#how-to-setup-a-single-calculation","title":"How to setup a single calculation","text":"<p>We start by setting up and submitting a single VaspJob:</p> <pre><code>from jarvis.tasks.vasp.vasp import VaspJob, write_vaspjob\nfrom jarvis.io.vasp.inputs import Potcar, Incar, Poscar\nfrom jarvis.db.jsonutils import dumpjson\nfrom jarvis.core.atoms import Atoms\nfrom jarvis.core.kpoints import Kpoints3D\nfrom jarvis.tasks.queue_jobs import Queue\nimport os\n\n# Load/build crystal structure\nmat = Poscar.from_file('POSCAR')\n# coords = [[0, 0, 0], [0.25, 0.25, 0.25]]\n# elements = [\"Si\", \"Si\"]\n# box = [[2.715, 2.715, 0], [0, 2.715, 2.715], [2.715, 0, 2.715]]\n# atoms = Atoms(lattice_mat=box, coords=coords, elements=elements)\n# mat = Poscar(atoms)\n# mat.comment = \"Silicon\"\n\n# Build INCAR file\ndata = dict(\n    PREC=\"Accurate\",\n    ISMEAR=0,\n    SIGMA=0.01,\n    IBRION=2,\n    ISIF=3,\n    GGA=\"BO\",\n    PARAM1=0.1833333333,\n    PARAM2=0.2200000000,\n    LUSE_VDW=\".TRUE.\",\n    AGGAC=0.0000,\n    EDIFF=\"1E-7\",\n    EDIFFG=\"-1E-3\",\n    NELM=400,\n    ISPIN=2,\n    LCHARG=\".FALSE.\",\n    LVTOT=\".FALSE.\",\n    LVHAR=\".FALSE.\",\n    LWAVE=\".FALSE.\",\n)\ninc = Incar(data)\n# Build POTCAR info\n# export VASP_PSP_DIR = 'PATH_TO_YOUR_PSP'\npot = Potcar.from_atoms(mat.atoms)\n#pot = Potcar(elements=mat.atoms.elements)\n\n# Build Kpoints info\nkp = Kpoints3D().automatic_length_mesh(\n    lattice_mat=mat.atoms.lattice_mat, length=20\n)\n\nvasp_cmd = \"PATH_TO vasp_std\"\ncopy_files = [\"PATH_TO vdw_kernel.bindat\"]\njobname = \"MAIN-RELAX@JVASP-1002\"\njob = VaspJob(\n    poscar=mat,\n    incar=inc,\n    potcar=pot,\n    kpoints=kp,\n    vasp_cmd=vasp_cmd,\n    copy_files=copy_files,\n    jobname=jobname,\n)\n\ndumpjson(data=job.to_dict(), filename=\"job.json\")\nwrite_vaspjob(pyname=\"job.py\", job_json=\"job.json\")\n</code></pre> <p>The job.py can now be run on a cluster or on a PC as a python script. For running this job on a PBS cluster,</p> <pre><code>submit_cmd = [\"qsub\", \"submit_job\"]\n# Example job commands, need to change based on your cluster\njob_line = (\n    \"source activate my_jarvis \\n\"\n    + \"python job.py\"\n)\nname = \"TestJob\"\ndirectory = os.getcwd()\nQueue.pbs(\n    job_line=job_line,\n    jobname=name,\n    directory=directory,\n    submit_cmd=submit_cmd,\n    )\n</code></pre>"},{"location":"tutorials/#how-to-setup-high-throughput-calculations","title":"How to setup high-throughput calculations","text":"<p>Currently, JARVIS-Tools can be used to submit job with SLURM and PBS clusters only. For high-throughput automated submissions one can use pre-build <code>JobFactory</code> module that allows automatic calculations for a series of properties.</p> <pre><code># List of materials to run high-throughput calculations on\nids = ['POSCAR-1.vasp','POSCAR-2.vasp','POSCAR-3.vasp']\n\nfrom jarvis.tasks.vasp.vasp import (\n    JobFactory,\n    VaspJob,\n    GenericIncars,\n    write_jobfact,\n)\nfrom jarvis.io.vasp.inputs import Potcar, Incar, Poscar\nfrom jarvis.db.jsonutils import dumpjson\nfrom jarvis.db.figshare import data\nfrom jarvis.core.atoms import Atoms\nfrom jarvis.tasks.queue_jobs import Queue\nimport os\nvasp_cmd = \"mpirun PATH_TO vasp_std\"\ncopy_files = [\"PATH_TO vdw_kernel.bindat\"]\nsubmit_cmd = [\"qsub\", \"submit_job\"]\n\n# For slurm\n# submit_cmd = [\"sbatch\", \"submit_job\"]\n\nsteps = [\n    \"ENCUT\",\n    \"KPLEN\",\n    \"RELAX\",\n    \"BANDSTRUCT\",\n    \"OPTICS\",\n    \"MBJOPTICS\",\n    \"ELASTIC\",\n]\nincs = GenericIncars().optb88vdw().incar.to_dict()\n\nfor id in ids:\n    mat = Poscar.from_file(id)\n    cwd_home = os.getcwd()\n    dir_name = id.split('.vasp')[0] + \"_\" + str(\"PBEBO\")\n    if not os.path.exists(dir_name):\n        os.makedirs(dir_name)\n    os.chdir(dir_name)\n    job = JobFactory(\n        vasp_cmd=vasp_cmd,\n        poscar=mat,\n        steps=steps,\n        copy_files=copy_files,\n        use_incar_dict=incs,\n    )\n\n    dumpjson(data=job.to_dict(), filename=\"job_fact.json\")\n    write_jobfact(\n        pyname=\"job_fact.py\",\n        job_json=\"job_fact.json\",\n        input_arg=\"v.step_flow()\",\n    )\n\n    # Example job commands, need to change based on your cluster\n    job_line = (\n        \"source activate my_jarvis \\n\"\n        + \"python job_fact.py\"\n    )\n    name = id\n    directory = os.getcwd()\n    Queue.pbs(\n        job_line=job_line,\n        jobname=name,\n        #partition=\"\",\n        walltime=\"24:00:00\",\n        #account=\"\",\n        cores=12,\n        directory=directory,\n        submit_cmd=submit_cmd,\n    )\n    os.chdir(cwd_home)\n    \"\"\"\n    # For Slurm clusters\n    Queue.slurm(\n        job_line=job_line,\n        jobname=name,\n        directory=directory,\n        submit_cmd=submit_cmd,\n    )\n    os.chdir(cwd_home)\n    \"\"\"\n</code></pre> <p>We provide modules to convert the calculation informato to <code>XML</code> which can be converted to <code>HTML</code> using <code>XSLT</code>. An example is give below:</p> <pre><code>from jarvis.db.vasp_to_xml import VaspToApiXmlSchema\nfrom jarvis.db.restapi import Api\nfolder=\"jarvis/jarvis/examples/vasp/SiOptB88vdW\"\nfilename = \"JVASP-1002.xml\"\nVaspToApiXmlSchema(folder=folder).write_xml(filename=filename)\n</code></pre>"},{"location":"tutorials/#how-to-plot-electronic-bandstructure-and-dos","title":"How to plot electronic bandstructure and DOS","text":"<p>If you use the workflow used above, the density of states plot can be obtained using thr <code>vasprun.xml</code> file in MAIN-RELAX folder while the band-structure plot is obtained using <code>vasprun.xml</code> in MAIN-BAND folder.</p> <pre><code>from jarvis.io.vasp.outputs import Vasprun\nvrun = Vasprun('vasprun.xml')\n%matplotlib inline\nimport matplotlib.pyplot as plt\nplt.rcParams.update({'font.size': 22})\n\n# Bandstructure plot\nvrun.get_bandstructure(kpoints_file_path='KPOINTS')\n\n# DOS plot\nenergies, spin_up, spin_dn=vrun.total_dos\nplt.rcParams.update({'font.size': 22})\nplt.plot(energies,spin_up,label='Spin-up')\nplt.plot(energies,spin_dn,label='Spin-down')\nplt.xlabel('Energy(E-Ef)')\nplt.ylabel('DOS(arb.unit)')\nplt.xlim(-4,4)\nplt.legend()\n</code></pre>"},{"location":"tutorials/#how-to-obtain-elastic-constants","title":"How to obtain elastic constants","text":""},{"location":"tutorials/#how-to-plot-generate-an-stmstem-image","title":"How to plot generate an STM/STEM image","text":""},{"location":"tutorials/#how-to-plot-generate-a-dielectric-function-spectra-and-solar-eff","title":"How to plot generate a dielectric function spectra and solar eff.","text":""},{"location":"tutorials/#how-to-generateuse-electronic-wannier-tight-binding-model","title":"How to generate/use electronic Wannier tight binding model","text":""},{"location":"tutorials/#how-to-generate-fermi-surfaces","title":"How to generate Fermi-surfaces","text":""},{"location":"tutorials/#how-to-run-boltztrap-for-transport-properties","title":"How to run BoltzTrap for transport properties","text":""},{"location":"tutorials/#how-to-make-heterostructuresinterfaces","title":"How to make heterostructures/interfaces","text":""},{"location":"tutorials/#how-to-get-irraman-spectra","title":"How to get IR/Raman spectra","text":""},{"location":"tutorials/#how-to-get-piezoelecticdielecrricbec-constants","title":"How to get piezoelectic/dielecrric/BEC constants","text":""},{"location":"tutorials/#how-to-get-electric-field-gradients","title":"How to get electric field gradients","text":""},{"location":"tutorials/#how-to-get-work-function-of-a-surface","title":"How to get work-function of a surface","text":""},{"location":"tutorials/#how-to-get-exfoliation-energy-of-a-2d-material","title":"How to get exfoliation energy of a 2D material","text":""},{"location":"tutorials/#how-to-runanalyze-md-staticdynamic-calculation-using-lammps","title":"How to run/analyze MD static/dynamic calculation using LAMMPS","text":"<p>Molecular dynamics/classical force-field calculations can be carried out with LAMMPS software as in JARVIS-FF. An example for running LAMMPS is given below. Here, a <code>LammpsJob</code> module is defined with the help of atoms, pair-style, coefficient, and template file (*.mod file) to control the calculations.</p>"},{"location":"tutorials/#how-to-run-calculation","title":"How to run calculation","text":"<pre><code>from jarvis.tasks.lammps.lammps import LammpsJob, JobFactory\nfrom jarvis.core.atoms import Atoms\nfrom jarvis.db.figshare import get_jid_data\nfrom jarvis.analysis.structure.spacegroup import Spacegroup3D\n\n\n# atoms = Atoms.from_poscar('POSCAR')\n# Get Aluminum FCC from JARVIS-DFT database\ntmp_dict = get_jid_data(jid=\"JVASP-816\", dataset=\"dft_3d\")[\"atoms\"]\natoms = Atoms.from_dict(tmp_dict)\n\n# Get conventional cell\nspg = Spacegroup3D(atoms)\ncvn_atoms = spg.conventional_standard_structure\n\n# Set-up path to force-field/potential file, .mod file. and lammps executable\nff = \"/users/knc6/Software/LAMMPS/lammps-master/potentials/Al_zhou.eam.alloy\"\nmod = \"/users/knc6/Software/Devs/jarvis/jarvis/tasks/lammps/templates/inelast.mod\"\ncmd = \"/users/knc6/Software/LAMMPS/lammps-master/src/lmp_serial&lt;in.main&gt;out\"\nparameters = {\n    \"pair_style\": \"eam/alloy\",\n    \"pair_coeff\": ff,\n    \"atom_style\": \"charge\",\n    \"control_file\": mod,\n}\n\n\n# Test LammpsJob\nlmp = LammpsJob(\n    atoms=cvn_atoms, parameters=parameters, lammps_cmd=cmd, jobname=\"Test\"\n).runjob()\n\n# Test in a high-throughput\njob_fact = JobFactory(pair_style=\"eam/alloy\", name=\"my_first_lammps_run\")\njob_fact.all_props_eam_alloy(atoms=cvn_atoms, ff_path=ff, lammps_cmd=cmd)\n</code></pre>"},{"location":"tutorials/#how-to-analyze-data","title":"How to analyze data","text":"<p>An example to parse LAMMPS calculation folder using the above workflow is shown below:</p> <pre><code>from jarvis.io.lammps.outputs import parse_material_calculation_folder\nfolder = '/home/users/knc6/Software/jarvis/jarvis/examples/lammps/Aleam'\ndata = parse_material_calculation_folder(folder)\nprint (data)\n</code></pre> <p>The calculation data can now be converted into XML files as follows. The XML with the help of XSLT is converted into an HTML page.</p> <pre><code>from jarvis.db.lammps_to_xml import write_xml\nwrite_xml(data=data,filename='JLMP-123.xml')\n</code></pre>"},{"location":"tutorials/#how-to-runanalyze-dft-static-calculation-using-quantum-espresso","title":"How to run/analyze DFT static calculation using Quantum espresso","text":"<p>Quantum ESPRESSO is a suite for first-principles electronic-structure calculations and materials modeling, distributed for free and as free software under the GNU General Public License. It is based on density-functional theory, plane wave basis sets, and pseudopotentials.</p>"},{"location":"tutorials/#how-to-setup-a-single-calculation_1","title":"How to setup a single calculation","text":"<p>An example for running QE simulation is shown below:</p> <pre><code>from jarvis.core.kpoints import Kpoints3D\nfrom jarvis.core.atoms import Atoms\nbox = [[2.715, 2.715, 0], [0, 2.715, 2.715], [2.715, 0, 2.715]]\ncoords = [[0, 0, 0], [0.25, 0.25, 0.25]]\nelements = [\"Si\", \"Si\"]\nSi = Atoms(lattice_mat=box, coords=coords, elements=elements)\nprint(Si)\nkp = Kpoints3D().automatic_length_mesh(\n    lattice_mat=Si.lattice_mat, length=20\n)\nqe = QEinfile(Si, kp)\nqe.write_file()\nkp = Kpoints3D().kpath(atoms=Si)\nqe = QEinfile(Si, kp)\nqe.write_file(\"qe.in2\")\nsp = qe.atomic_species_string()\nsp = qe.atomic_cell_params()\nprint(\"sp\", sp)\nprint(qe.input_params['system_params']['nat'])\n$PATH_TO_PWSCF/pw.x -i qe.in\n</code></pre>"},{"location":"tutorials/#how-to-setup-high-throughput-calculations_1","title":"How to setup high-throughput calculations","text":""},{"location":"tutorials/#how-to-traing-jarvis-cfid-ml-models-using-sklearnlightgbm","title":"How to traing JARVIS-CFID ML models using sklearn/lightgbm","text":"<p>There are several methods to train atomistic property ML models such as based on hand-crafted descritprs and graph neural network. Examples of such methods are: JARVIS-CFID (Classical Force-Field Inspired Descriptors) for descriptors based training and JARVIS-ALIGNN (Atomistic Line Graph Neural Network) based on GNNs. In this section we discuss the JARVIS-CFID ( <code>jarvis.ai.descriptors.cfid</code>), which can be used for training models with only chemical formula or chemical formula+structure information.</p>"},{"location":"tutorials/#how-to-train-chemical-formula-only-datasets","title":"How to train chemical formula only datasets","text":"<p>For each chemical formula, we can obtain 438 descriptors consisting of features such as avergae electronegativity, average boiling points of elements etc. An example of getting descriptors isshown below:</p> <pre><code>import numpy as np\nfrom jarvis.core.composition import Composition\nfrom jarvis.core.specie import Specie\nfrom jarvis.ai.pkgs.lgbm.regression import regression\nfrom jarvis.ai.descriptors.cfid import get_chem_only_descriptors\n\n# Load a dataset, you can use pandas read_csv also to generte my_data\n# Here is a sample dataset\nmy_data = [\n    [\"CoAl\", 1],\n    [\"CoNi\", 2],\n    [\"CoNb2Ni5\", 3],\n    [\"Co1.2Al2.3NiRe2\", 4],\n    [\"Co\", 5],\n    [\"CoAlTi\", 1],\n    [\"CoNiTi\", 2],\n    [\"CoNb2Ni5Ti\", 3],\n    [\"Co1.2Al2.3NiRe2Ti\", 4],\n    [\"CoTi\", 5],\n    [\"CoAlFe\", 1],\n    [\"CoNiFe\", 2],\n    [\"CoNb2Ni5Fe\", 3],\n    [\"Co1.2Al2.3NiRe2Fe\", 4],\n    [\"CoFe\", 5],\n]\n\n\n# Convert my_data to numpy array\nX = []\nY = []\nIDs = []\nfor ii, i in enumerate(my_data):\n    X.append(get_chem_only_descriptors(i[0]))\n    Y.append(i[1])\n    IDs.append(ii)\n\nX = np.array(X)\nY = np.array(Y).reshape(-1, 1)\nIDs = np.array(IDs)\n</code></pre> <p>Now, we can use different ML algorithms on the descriptors and dataset such as linear regression, random forest, gradient boosting etc.</p> <p>An example, for using LightGBM with jarvis-tools wrapper code is shown below:</p> <pre><code># Train a LightGBM regression model\nconfig = {\"n_estimators\": 5, \"learning_rate\": 0.01, \"num_leaves\": 2}\n# The regression module does feature pre-processing as well\n# Change config settings to improve model such as by hyper-parameter tuning\ninfo = regression(X=X, Y=Y, jid=IDs, feature_importance=False, config=config)\n\n\n# Print performance metrices\n# Print performance metrices\nprint(\n    'r2=',info[\"reg_scores\"][\"r2\"],\n    'MAE=',info[\"reg_scores\"][\"mae\"],\n    'RMSE=',info[\"reg_scores\"][\"rmse\"],\n)\n</code></pre>"},{"location":"tutorials/#how-to-train-regression-model","title":"How to train regression model","text":"<p>Suppose we have 60000 materials, and we get 1557 descriptor for each material (438 chemical as above as well as structure and charge descriptors), we will have a 60000x1557 matrix. Let's call this matrix as 'x' or input matrix. Next, we can get target ('y') data either from DFT, FF calculations or experiments. For example, we can choose formation energies of 60000 materials in the JARVIS-DFT as the dtarget data giving 60000x1 matrix.</p> <p>Now, we can use a ML/AI algorithm to establish statistical relation between the x and y data. Once trained we get a trained model, which can be stored in say pickle or joblib format.</p> <p>For a new material now, it can be converted into CFID i.e. 1x1557 matrix which when fed to the model will give 1x1 prediction hence the ML prediction. We can use a range of ML algorithms such as linear regression, decision trees, Gaussian processes etc. We find with CFID descriptors, gradient boosting decision trees (especially in LightGBM) gives one of the most accurate results. We provide tools to run with major ML packages such as scikit-learn, tensorflow, pytorch, lightgbm etc. Example-1:</p> <pre><code># An example of JARVIS-ML training\nfrom jarvis.ai.pkgs.utils import get_ml_data\nfrom jarvis.ai.pkgs.utils import regr_scores\nX,y,jid=get_ml_data()\n#Formation energy for 3D materials, you can choose other properties/dataset as well\nimport lightgbm as lgb\nfrom sklearn.model_selection import train_test_split\nlgbm = lgb.LGBMRegressor(device= 'gpu',n_estimators= 1170,learning_rate= 0.15375236057119931,num_leaves= 273)       \nX_train, X_test, y_train, y_test, jid_train, jid_test = train_test_split(X, y, jid, random_state=1, test_size=.1)\nlgbm.fit(X_train,y_train)\npred = lgbm.predict(X_test)\nreg_sc = regr_scores(y_test, pred)\nprint (reg_sc['mae'])\n</code></pre>"},{"location":"tutorials/#how-to-traing-jarvis-alignn-ml-models-using-pytorch","title":"How to traing JARVIS-ALIGNN ML models using PyTorch","text":""},{"location":"tutorials/#how-to-train-regression-model_1","title":"How to train regression model","text":"<p>How to train classification model ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</p>"},{"location":"tutorials/#how-to-use-quantum-computation-algorithms-using-qiskittequilapennylane","title":"How to use quantum computation algorithms using Qiskit/Tequila/Pennylane","text":"<p>Quantum chemistry is one of the most attractive applications for quantum computations. Predicting the energy levels of a Hamiltonian is a key problem in quantum chemistry. Variational quantum eigen solver (VQE) is one of the most celebrated methods for predicting an approximate ground state of a Hamiltonian on a quantum computer following the variational principles of quantum mechanics.VQE utilizes Ritz variational principle where a quantum computer is used to prepare a wave function ansatz of the system and estimate the expectation value of its electronic Hamiltonian while a classical optimizer is used to adjust the quantum circuit parameters in order to find the ground state energy. A typical VQE task is carried out as follows: an ansatz/circuit model with tunable parameters is constructed and a quantum circuit capable of representing this ansatz is designed. In this section, we show a few examples to apply quantum algorithms for solids using Wannier-tight binding Hamiltonians (WTBH). WTBHs can be generated from several DFT codes. Here, we use JARVIS-WTBH database.</p>"},{"location":"tutorials/#how-to-generate-circuit-model","title":"How to generate circuit model","text":"<p>Developing a heuristic quantum circuit model is probably the most challenging part of applying quantum algorithms. Fortunately, there are few well-known generalized models that we can use or generate ourselves. There are several circuit models (for a fixed number of qubits and repeat units) available in <code>jarvis.core.circuits.</code>. In the following example, we use circuit6/EfficientSU2 model and use it to predict electronic energy levels (at a K-point in the Brillouin zone) of FCC Aluminum using a WTBH.</p> <pre><code>from jarvis.db.figshare import get_wann_electron, get_wann_phonon, get_hk_tb\nfrom jarvis.io.qiskit.inputs import HermitianSolver\nfrom jarvis.core.circuits import QuantumCircuitLibrary\nfrom qiskit import Aer\n\nbackend = Aer.get_backend(\"statevector_simulator\")\n# Aluminum JARVIS-ID: JVASP-816\nwtbh, Ef, atoms = get_wann_electron(\"JVASP-816\") \nkpt = [0.5, 0., 0.5] # X-point\nhk = get_hk_tb(w=wtbh, k=kpt)\nHS = HermitianSolver(hk)\nn_qubits = HS.n_qubits()\ncirc = QuantumCircuitLibrary(n_qubits=n_qubits).circuit6()\nen, vqe_result, vqe = HS.run_vqe(var_form=circ, backend=backend)\nvals,vecs = HS.run_numpy()\n# Ef: Fermi-level\nprint('Classical, VQE (eV):', vals[0]-Ef, en-Ef)\nprint('Show model\\n', circ)\n</code></pre>"},{"location":"tutorials/#how-to-run-cals-on-simulators","title":"How to run cals. on simulators","text":"<p>In the above example, we run simulations on <code>statevector_simulator</code>. Qiskit provides several other simulators, which can also be used.</p>"},{"location":"tutorials/#how-to-run-cals-on-actual-quantum-computers","title":"How to run cals. on actual quantum computers","text":"<p>To run calculations on real quantum computers, we just replace the <code>backend</code> parameter above such as the following:</p> <pre><code>token='Get Token from your IBM account' \nqiskit.IBMQ.save_account(token)\nprovider = IBMQ.load_account()\nbackend = provider.get_backend('ibmq_5_yorktown')\n</code></pre> <p>Your job will put in a queue and as the simulation complete result will be sent back to you. Note that there might be a lot of jobs in the queue already, so it might take a while. You may run simulations using IBM GUI or use something like Jupyter notebook/Colab notebook.</p>"}]}